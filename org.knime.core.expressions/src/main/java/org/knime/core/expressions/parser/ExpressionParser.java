
// !! this file is automatically generated; do not modify.

package org.knime.core.expressions.parser;

import org.rekex.parser.PegParser;
import org.rekex.parser.ParseResult;

import java.util.List;

import org.knime.core.expressions.parser.ExpressionGrammar.Atom;
import org.knime.core.expressions.parser.ExpressionGrammar.Comparison;
import org.knime.core.expressions.parser.ExpressionGrammar.Conjunction;
import org.knime.core.expressions.parser.ExpressionGrammar.CtorCatalog;
import org.knime.core.expressions.parser.ExpressionGrammar.Digits;
import org.knime.core.expressions.parser.ExpressionGrammar.Disjunction;
import org.knime.core.expressions.parser.ExpressionGrammar.Expr;
import org.knime.core.expressions.parser.ExpressionGrammar.Factor;
import org.knime.core.expressions.parser.ExpressionGrammar.Inversion;
import org.knime.core.expressions.parser.ExpressionGrammar.OptWs;
import org.knime.core.expressions.parser.ExpressionGrammar.StrConst;
import org.knime.core.expressions.parser.ExpressionGrammar.Sum;
import org.knime.core.expressions.parser.ExpressionGrammar.Term;
import org.rekex.helper.datatype.SepBy;
import org.rekex.helper.datatype.SepBy.Empty;
import org.rekex.helper.datatype.SepBy1;
import org.rekex.helper.datatype.seq.Seq2;


// Generated recursive descent PEG parser by Rekex

// rootType: Expr

// !! this file is automatically generated; do not modify.
@SuppressWarnings({"all", "unchecked"})
public class ExpressionParser implements PegParser<Expr>
{
    static final int rootTypeRuleId = 0;

    final CtorCatalog catalog;
    public ExpressionParser(CtorCatalog catalog)
    {
        this.catalog = catalog;
    }

    @Override
    public ParseResult<Expr> parse(CharSequence chars, int start, int end)
    {
        _State state = new _State();
        state.catalog = this.catalog;
        state.chars = chars;
        state.start = start;
        state.end = end;
        state.inputInfo = new org.rekex.parser.InputInfo(chars, start, end);

        try
        {
            state = match(rootTypeRuleId, state, -1);
        }
        catch (_FatalEx fatalEx)
        {
            var stack = pathToStack(state.path, state.pathLen);
            return new ParseResult.Fatal<>(fatalEx.position, fatalEx.cause, stack);
        }

        if(!state.fail)
        {
            Expr obj = state.pickObj();
            if(state.start==state.end)
                return new ParseResult.Full<>(obj);
            else
                return new ParseResult.Partial<>(obj, state.start);
        }
        else
        {
            var stack = pathToStack(state.maxFailPath, state.maxFailPath.length);
            String msg = failMsg(state.maxFailReason, state.maxFailEx, _DatatypeList.list.get(state.maxFailRuleId));
            return new ParseResult.Fail<>(state.maxFailPos, msg, state.maxFailEx, stack);
        }
    }

    final static class _State implements Cloneable
    {
        CtorCatalog catalog;
        CharSequence chars;
        int start;
        int end;

        org.rekex.parser.InputInfo inputInfo;

        boolean fail;
        // if fail==false, match is success, obj is set (null is allowed)
        Object obj;

        int[] path = new int[64];
        int pathLen = 0;

        int maxFailPos = -1;
        int[] maxFailPath;
        int maxFailReason;
        Exception maxFailEx;
        int maxFailRuleId;

        public _State clone()
        {
            try {
                return (_State)super.clone();
            } catch (CloneNotSupportedException e) {
                throw new AssertionError(e);
            }
        }

        int gStart, gEnd; // tmp data buffer for regex

        void pathPush(int ruleId, int subIndex)
        {
            if(pathLen+3 > path.length)
                path = java.util.Arrays.copyOf(path, path.length+64);
            path[pathLen++] = ruleId;
            path[pathLen++] = this.start;
            path[pathLen++] = subIndex;
        }
        void pathPop()
        {
            pathLen -= 3;
        }

        _State ok(Object obj)
        {
            this.fail = false;
            this.obj = obj;
            return this;
        }
        <T> T pickObj()
        {
            T t = (T)obj;
            obj = null;
            return t;
        }

        _State fail(int position, int reason, Exception ex, int ruleId, int startReset)
        {
            if(position>maxFailPos)
            {
                maxFailPos = position;
                maxFailPath = java.util.Arrays.copyOf(path, pathLen);
                maxFailReason = reason;
                maxFailEx = ex;
                maxFailRuleId = ruleId;
            }
            return fail(startReset);
        }
        _State fail(int startReset)
        {
            this.fail = true;
            this.obj = null;
            this.start = startReset;
            return this;
        }

    }
    static final int failReason_predicate = 0;   // info: Exception
    static final int failReason_neg = 1;         // info: subrule ID
    static final int failReason_regex = 2;
    static final int failReason_regex_group = 3;

    static String failMsg(int reason, Exception ex, org.rekex.annotype.AnnoType type)
    {
        String typeStr = type.toString(false);
        return switch (reason){
            case failReason_predicate
                -> ex.getMessage()!=null ? ex.getMessage() : ex.toString();
            case failReason_neg
                -> typeStr + " failed; input matched subrule";
            case failReason_regex
                -> "Input does not match regex: "+typeStr;
            case failReason_regex_group
                -> "Input does not match regex group: "+typeStr;
            default -> throw new AssertionError("unexpected reason: "+reason);
        };
    }

    static java.util.ArrayList<ParseResult.Node> pathToStack(int[] path, int pathLen)
    {
        java.util.ArrayList<ParseResult.Node> stack = new java.util.ArrayList<>(pathLen/2);
        for(int i=pathLen-1; i>=0;)
        {
            int _subIndex = path[i--];
            int _start = path[i--];
            int _ruleId = path[i--];
            var datatype = _DatatypeList.list.get(_ruleId);
            stack.add(new ParseResult.Node(datatype, _start, _subIndex));
        }
        return stack;
    }

    static class _FatalEx extends Exception
    {
        final int position;
        final Exception cause;
        _FatalEx(int position, Exception cause)
        {
            super(null, null, false, false);
            this.position = position;
            this.cause = cause;
        }
    }

    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    // rules
    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

    static _State match(int ruleId, _State state, int subIndex) throws _FatalEx
    {
        state.pathPush(ruleId, subIndex);
        state = switch(ruleId){
            case 0 -> rule_0(state); // Expr
            case 1 -> rule_1(state); // Disjunction
            case 2 -> rule_2(state); // SepBy1<Conjunction,@Str("or")String>
            case 3 -> rule_3(state); // Conjunction
            case 4 -> rule_4(state); // List<Seq2<@Str("or")String,Conjunction>>
            case 5 -> rule_5(state); // SepBy1<Inversion,@Str("and")String>
            case 6 -> rule_6(state); // Seq2<@Str("or")String,Conjunction>
            case 7 -> rule_7(state); // Inversion
            case 8 -> rule_8(state); // List<Seq2<@Str("and")String,Inversion>>
            case 9 -> rule_9(state); // @Str("or")String
            case 10 -> rule_10(state); // Inversion
            case 11 -> rule_11(state); // Inversion
            case 12 -> rule_12(state); // Seq2<@Str("and")String,Inversion>
            case 13 -> rule_13(state); // OptWs
            case 14 -> rule_14(state); // @Str("not")String
            case 15 -> rule_15(state); // Comparison
            case 16 -> rule_16(state); // @Str("and")String
            case 17 -> rule_17(state); // @Word("")String
            case 18 -> rule_18(state); // Comparison
            case 19 -> rule_19(state); // Comparison
            case 20 -> rule_20(state); // Sum
            case 21 -> rule_21(state); // @Str({"==","=","!=","<=","<",">=",">"})String
            case 22 -> rule_22(state); // SepBy1<Term,@Ch("+-")String>
            case 23 -> rule_23(state); // Term
            case 24 -> rule_24(state); // List<Seq2<@Ch("+-")String,Term>>
            case 25 -> rule_25(state); // SepBy1<Factor,@Ch("*/%")String>
            case 26 -> rule_26(state); // Seq2<@Ch("+-")String,Term>
            case 27 -> rule_27(state); // Factor
            case 28 -> rule_28(state); // List<Seq2<@Ch("*/%")String,Factor>>
            case 29 -> rule_29(state); // @Ch("+-")String
            case 30 -> rule_30(state); // Factor
            case 31 -> rule_31(state); // Factor
            case 32 -> rule_32(state); // Seq2<@Ch("*/%")String,Factor>
            case 33 -> rule_33(state); // Atom
            case 34 -> rule_34(state); // @Ch("*/%")String
            case 35 -> rule_35(state); // Atom
            case 36 -> rule_36(state); // Atom
            case 37 -> rule_37(state); // Atom
            case 38 -> rule_38(state); // Atom
            case 39 -> rule_39(state); // Atom
            case 40 -> rule_40(state); // Atom
            case 41 -> rule_41(state); // Atom
            case 42 -> rule_42(state); // Atom
            case 43 -> rule_43(state); // Atom
            case 44 -> rule_44(state); // @Ch("$")Void
            case 45 -> rule_45(state); // @Ch("[")Void
            case 46 -> rule_46(state); // StrConst
            case 47 -> rule_47(state); // @Ch("]")Void
            case 48 -> rule_48(state); // @Ch(except="\\\" \t\n\r$()+-*/%",range={32,1114111})int[]
            case 49 -> rule_49(state); // @Regex("MISSING")String
            case 50 -> rule_50(state); // @Regex("[a-zA-Z_]\\w*")String
            case 51 -> rule_51(state); // @Ch("(")Void
            case 52 -> rule_52(state); // SepBy<Expr,@Ch(",")String>
            case 53 -> rule_53(state); // @Ch(")")Void
            case 54 -> rule_54(state); // Digits
            case 55 -> rule_55(state); // @Regex("[.][0-9]*([e][+-]?[0-9]+)?[fFdD]?")String
            case 56 -> rule_56(state); // @Regex("[.][0-9]+([e][+-]?[0-9]+)?[fFdD]?")String
            case 57 -> rule_57(state); // @Ch("\"")Void
            case 58 -> rule_58(state); // int[]
            case 59 -> rule_59(state); // @Ch(except="\\\" \t\n\r$()+-*/%",range={32,1114111})int
            case 60 -> rule_60(state); // SepBy1<Expr,@Ch(",")String>
            case 61 -> rule_61(state); // Empty<Expr,@Ch(",")String>
            case 62 -> rule_62(state); // @Regex("[0-9]+")String
            case 63 -> rule_63(state); // int
            case 64 -> rule_64(state); // List<Seq2<@Ch(",")String,Expr>>
            case 65 -> rule_65(state); // int
            case 66 -> rule_66(state); // int
            case 67 -> rule_67(state); // int
            case 68 -> rule_68(state); // Seq2<@Ch(",")String,Expr>
            case 69 -> rule_69(state); // @Ch(except="\\\"",range={32,1114111})int
            case 70 -> rule_70(state); // @Ch("\\")Void
            case 71 -> rule_71(state); // @Ch("\\\"/bfnrt")char
            case 72 -> rule_72(state); // @Ch("u")Void
            case 73 -> rule_73(state); // byte
            case 74 -> rule_74(state); // @Ch(",")String
            case 75 -> rule_75(state); // @Regex("[0-9A-Fa-f]")char
            default -> throw new AssertionError("unknown ruleId: "+ruleId);
        };
        state.pathPop();
        return state;
    }

    // concat rule for: Expr
    static _State rule_0(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(1, state, 0); // arg_0: Disjunction
        if(state.fail)
            return state.fail(start0);
        Disjunction arg_0 = state.pickObj();

        Expr value;
        try{
            value = state.catalog.expr(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Disjunction
    static _State rule_1(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(2, state, 0); // arg_0: SepBy1<Conjunction,@Str("or")String>
        if(state.fail)
            return state.fail(start0);
        SepBy1<Conjunction, String> arg_0 = state.pickObj();

        Disjunction value;
        try{
            value = state.catalog.disjunction(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: SepBy1<Conjunction,@Str("or")String>
    static _State rule_2(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(3, state, 0); // arg_0: Conjunction
        if(state.fail)
            return state.fail(start0);
        Conjunction arg_0 = state.pickObj();

        state = match(4, state, 1); // arg_1: List<Seq2<@Str("or")String,Conjunction>>
        if(state.fail)
            return state.fail(start0);
        List<Seq2<String, Conjunction>> arg_1 = state.pickObj();

        SepBy1<Conjunction, String> value;
        try{
            value = SepBy1.ctor(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Conjunction
    static _State rule_3(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(5, state, 0); // arg_0: SepBy1<Inversion,@Str("and")String>
        if(state.fail)
            return state.fail(start0);
        SepBy1<Inversion, String> arg_0 = state.pickObj();

        Conjunction value;
        try{
            value = state.catalog.conjunction(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // repeat rule for: List<Seq2<@Str("or")String,Conjunction>>
    static _State rule_4(_State state) throws _FatalEx
    {
        state = match_repeat(state, 4, 6, 0, Integer.MAX_VALUE);
        if(state.fail)
            return state;
        java.util.ArrayList<Seq2<String, Conjunction>> list = state.pickObj();
        list.trimToSize();
        return state.ok(list);
    }

    // concat rule for: SepBy1<Inversion,@Str("and")String>
    static _State rule_5(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(7, state, 0); // arg_0: Inversion
        if(state.fail)
            return state.fail(start0);
        Inversion arg_0 = state.pickObj();

        state = match(8, state, 1); // arg_1: List<Seq2<@Str("and")String,Inversion>>
        if(state.fail)
            return state.fail(start0);
        List<Seq2<String, Inversion>> arg_1 = state.pickObj();

        SepBy1<Inversion, String> value;
        try{
            value = SepBy1.ctor(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Seq2<@Str("or")String,Conjunction>
    static _State rule_6(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(9, state, 0); // arg_0: @Str("or")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        state = match(3, state, 1); // arg_1: Conjunction
        if(state.fail)
            return state.fail(start0);
        Conjunction arg_1 = state.pickObj();

        Seq2<String, Conjunction> value;
        try{
            value = new Seq2<String, Conjunction>(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // alt rule for: Inversion
    static _State rule_7(_State state) throws _FatalEx
    {
        state = match(10, state, 0); // Inversion
        if(!state.fail)
            return state;

        state = match(11, state, 1); // Inversion
        if(!state.fail)
            return state;

        return state;
    }


    // repeat rule for: List<Seq2<@Str("and")String,Inversion>>
    static _State rule_8(_State state) throws _FatalEx
    {
        state = match_repeat(state, 8, 12, 0, Integer.MAX_VALUE);
        if(state.fail)
            return state;
        java.util.ArrayList<Seq2<String, Inversion>> list = state.pickObj();
        list.trimToSize();
        return state.ok(list);
    }

    // regex rule for: @Str("or")String
    static _State rule_9(_State state)
    {
        return match_regex_str(state, 9, pattern_9, 0);
    }
    static final java.util.regex.Pattern pattern_9 = java.util.regex.Pattern.compile("or", 0);

    // concat rule for: Inversion
    static _State rule_10(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(14, state, 1); // arg_1: @Str("not")String
        if(state.fail)
            return state.fail(start0);
        String arg_1 = state.pickObj();

        state = match(15, state, 2); // arg_2: Comparison
        if(state.fail)
            return state.fail(start0);
        Comparison arg_2 = state.pickObj();

        Inversion value;
        try{
            value = state.catalog.inversion(arg_0, arg_1, arg_2);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Inversion
    static _State rule_11(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(15, state, 0); // arg_0: Comparison
        if(state.fail)
            return state.fail(start0);
        Comparison arg_0 = state.pickObj();

        Inversion value;
        try{
            value = state.catalog.inversion(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Seq2<@Str("and")String,Inversion>
    static _State rule_12(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(16, state, 0); // arg_0: @Str("and")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        state = match(7, state, 1); // arg_1: Inversion
        if(state.fail)
            return state.fail(start0);
        Inversion arg_1 = state.pickObj();

        Seq2<String, Inversion> value;
        try{
            value = new Seq2<String, Inversion>(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: OptWs
    static _State rule_13(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(17, state, 0); // arg_0: @Word("")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        OptWs value;
        try{
            value = state.catalog.optWs(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // regex rule for: @Str("not")String
    static _State rule_14(_State state)
    {
        return match_regex_str(state, 14, pattern_14, 0);
    }
    static final java.util.regex.Pattern pattern_14 = java.util.regex.Pattern.compile("not", 0);

    // alt rule for: Comparison
    static _State rule_15(_State state) throws _FatalEx
    {
        state = match(18, state, 0); // Comparison
        if(!state.fail)
            return state;

        state = match(19, state, 1); // Comparison
        if(!state.fail)
            return state;

        return state;
    }


    // regex rule for: @Str("and")String
    static _State rule_16(_State state)
    {
        return match_regex_str(state, 16, pattern_16, 0);
    }
    static final java.util.regex.Pattern pattern_16 = java.util.regex.Pattern.compile("and", 0);

    // regex rule for: @Word("")String
    static _State rule_17(_State state)
    {
        return match_regex_str(state, 17, pattern_17, 1);
    }
    static final java.util.regex.Pattern pattern_17 = java.util.regex.Pattern.compile("()[\\ \\t\\n\\r]*", 0);

    // concat rule for: Comparison
    static _State rule_18(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(20, state, 0); // arg_0: Sum
        if(state.fail)
            return state.fail(start0);
        Sum arg_0 = state.pickObj();

        state = match(21, state, 1); // arg_1: @Str({"==","=","!=","<=","<",">=",">"})String
        if(state.fail)
            return state.fail(start0);
        String arg_1 = state.pickObj();

        state = match(20, state, 2); // arg_2: Sum
        if(state.fail)
            return state.fail(start0);
        Sum arg_2 = state.pickObj();

        Comparison value;
        try{
            value = state.catalog.comparison(arg_0, arg_1, arg_2);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Comparison
    static _State rule_19(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(20, state, 0); // arg_0: Sum
        if(state.fail)
            return state.fail(start0);
        Sum arg_0 = state.pickObj();

        Comparison value;
        try{
            value = state.catalog.comparison(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Sum
    static _State rule_20(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(22, state, 0); // arg_0: SepBy1<Term,@Ch("+-")String>
        if(state.fail)
            return state.fail(start0);
        SepBy1<Term, String> arg_0 = state.pickObj();

        Sum value;
        try{
            value = state.catalog.sum(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // regex rule for: @Str({"==","=","!=","<=","<",">=",">"})String
    static _State rule_21(_State state)
    {
        return match_regex_str(state, 21, pattern_21, 0);
    }
    static final java.util.regex.Pattern pattern_21 = java.util.regex.Pattern.compile("==|=|!=|<=|<|>=|>", 0);

    // concat rule for: SepBy1<Term,@Ch("+-")String>
    static _State rule_22(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(23, state, 0); // arg_0: Term
        if(state.fail)
            return state.fail(start0);
        Term arg_0 = state.pickObj();

        state = match(24, state, 1); // arg_1: List<Seq2<@Ch("+-")String,Term>>
        if(state.fail)
            return state.fail(start0);
        List<Seq2<String, Term>> arg_1 = state.pickObj();

        SepBy1<Term, String> value;
        try{
            value = SepBy1.ctor(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Term
    static _State rule_23(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(25, state, 0); // arg_0: SepBy1<Factor,@Ch("*/%")String>
        if(state.fail)
            return state.fail(start0);
        SepBy1<Factor, String> arg_0 = state.pickObj();

        Term value;
        try{
            value = state.catalog.term(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // repeat rule for: List<Seq2<@Ch("+-")String,Term>>
    static _State rule_24(_State state) throws _FatalEx
    {
        state = match_repeat(state, 24, 26, 0, Integer.MAX_VALUE);
        if(state.fail)
            return state;
        java.util.ArrayList<Seq2<String, Term>> list = state.pickObj();
        list.trimToSize();
        return state.ok(list);
    }

    // concat rule for: SepBy1<Factor,@Ch("*/%")String>
    static _State rule_25(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(27, state, 0); // arg_0: Factor
        if(state.fail)
            return state.fail(start0);
        Factor arg_0 = state.pickObj();

        state = match(28, state, 1); // arg_1: List<Seq2<@Ch("*/%")String,Factor>>
        if(state.fail)
            return state.fail(start0);
        List<Seq2<String, Factor>> arg_1 = state.pickObj();

        SepBy1<Factor, String> value;
        try{
            value = SepBy1.ctor(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Seq2<@Ch("+-")String,Term>
    static _State rule_26(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(29, state, 0); // arg_0: @Ch("+-")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        state = match(23, state, 1); // arg_1: Term
        if(state.fail)
            return state.fail(start0);
        Term arg_1 = state.pickObj();

        Seq2<String, Term> value;
        try{
            value = new Seq2<String, Term>(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // alt rule for: Factor
    static _State rule_27(_State state) throws _FatalEx
    {
        state = match(30, state, 0); // Factor
        if(!state.fail)
            return state;

        state = match(31, state, 1); // Factor
        if(!state.fail)
            return state;

        return state;
    }


    // repeat rule for: List<Seq2<@Ch("*/%")String,Factor>>
    static _State rule_28(_State state) throws _FatalEx
    {
        state = match_repeat(state, 28, 32, 0, Integer.MAX_VALUE);
        if(state.fail)
            return state;
        java.util.ArrayList<Seq2<String, Factor>> list = state.pickObj();
        list.trimToSize();
        return state.ok(list);
    }

    // regex rule for: @Ch("+-")String
    static _State rule_29(_State state)
    {
        return match_regex_str(state, 29, pattern_29, 0);
    }
    static final java.util.regex.Pattern pattern_29 = java.util.regex.Pattern.compile("[\\+\\-]", 0);

    // concat rule for: Factor
    static _State rule_30(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(29, state, 1); // arg_1: @Ch("+-")String
        if(state.fail)
            return state.fail(start0);
        String arg_1 = state.pickObj();

        state = match(27, state, 2); // arg_2: Factor
        if(state.fail)
            return state.fail(start0);
        Factor arg_2 = state.pickObj();

        Factor value;
        try{
            value = state.catalog.factor(arg_0, arg_1, arg_2);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Factor
    static _State rule_31(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(33, state, 1); // arg_1: Atom
        if(state.fail)
            return state.fail(start0);
        Atom arg_1 = state.pickObj();

        Factor value;
        try{
            value = state.catalog.factor(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Seq2<@Ch("*/%")String,Factor>
    static _State rule_32(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(34, state, 0); // arg_0: @Ch("*/%")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        state = match(27, state, 1); // arg_1: Factor
        if(state.fail)
            return state.fail(start0);
        Factor arg_1 = state.pickObj();

        Seq2<String, Factor> value;
        try{
            value = new Seq2<String, Factor>(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // alt rule for: Atom
    static _State rule_33(_State state) throws _FatalEx
    {
        state = match(35, state, 0); // Atom
        if(!state.fail)
            return state;

        state = match(36, state, 1); // Atom
        if(!state.fail)
            return state;

        state = match(37, state, 2); // Atom
        if(!state.fail)
            return state;

        state = match(38, state, 3); // Atom
        if(!state.fail)
            return state;

        state = match(39, state, 4); // Atom
        if(!state.fail)
            return state;

        state = match(40, state, 5); // Atom
        if(!state.fail)
            return state;

        state = match(41, state, 6); // Atom
        if(!state.fail)
            return state;

        state = match(42, state, 7); // Atom
        if(!state.fail)
            return state;

        state = match(43, state, 8); // Atom
        if(!state.fail)
            return state;

        return state;
    }


    // regex rule for: @Ch("*/%")String
    static _State rule_34(_State state)
    {
        return match_regex_str(state, 34, pattern_34, 0);
    }
    static final java.util.regex.Pattern pattern_34 = java.util.regex.Pattern.compile("[\\*/%]", 0);

    // concat rule for: Atom
    static _State rule_35(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(44, state, 1); // arg_1: @Ch("$")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_1 = state.pickObj();

        state = match(45, state, 2); // arg_2: @Ch("[")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_2 = state.pickObj();

        state = match(46, state, 3); // arg_3: StrConst
        if(state.fail)
            return state.fail(start0);
        StrConst arg_3 = state.pickObj();

        state = match(47, state, 4); // arg_4: @Ch("]")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_4 = state.pickObj();

        state = match(13, state, 5); // arg_5: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_5 = state.pickObj();

        Atom value;
        try{
            value = state.catalog.column(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Atom
    static _State rule_36(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(44, state, 1); // arg_1: @Ch("$")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_1 = state.pickObj();

        state = match(48, state, 2); // arg_2: @Ch(except="\\\" \t\n\r$()+-*/%",range={32,1114111})int[]
        if(state.fail)
            return state.fail(start0);
        int[] arg_2 = state.pickObj();

        state = match(13, state, 3); // arg_3: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_3 = state.pickObj();

        Atom value;
        try{
            value = state.catalog.column(arg_0, arg_1, arg_2, arg_3);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Atom
    static _State rule_37(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(49, state, 1); // arg_1: @Regex("MISSING")String
        if(state.fail)
            return state.fail(start0);
        String arg_1 = state.pickObj();

        Atom value;
        try{
            value = state.catalog.missing(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Atom
    static _State rule_38(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(50, state, 1); // arg_1: @Regex("[a-zA-Z_]\\w*")String
        if(state.fail)
            return state.fail(start0);
        String arg_1 = state.pickObj();

        state = match(13, state, 2); // arg_2: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_2 = state.pickObj();

        state = match(51, state, 3); // arg_3: @Ch("(")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_3 = state.pickObj();

        state = match(52, state, 4); // arg_4: SepBy<Expr,@Ch(",")String>
        if(state.fail)
            return state.fail(start0);
        SepBy<Expr, String> arg_4 = state.pickObj();

        state = match(53, state, 5); // arg_5: @Ch(")")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_5 = state.pickObj();

        state = match(13, state, 6); // arg_6: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_6 = state.pickObj();

        Atom value;
        try{
            value = state.catalog.call(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5, arg_6);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Atom
    static _State rule_39(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(51, state, 1); // arg_1: @Ch("(")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_1 = state.pickObj();

        state = match(0, state, 2); // arg_2: Expr
        if(state.fail)
            return state.fail(start0);
        Expr arg_2 = state.pickObj();

        state = match(53, state, 3); // arg_3: @Ch(")")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_3 = state.pickObj();

        state = match(13, state, 4); // arg_4: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_4 = state.pickObj();

        Atom value;
        try{
            value = state.catalog.group(arg_0, arg_1, arg_2, arg_3, arg_4);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Atom
    static _State rule_40(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(54, state, 1); // arg_1: Digits
        if(state.fail)
            return state.fail(start0);
        Digits arg_1 = state.pickObj();

        state = match(55, state, 2); // arg_2: @Regex("[.][0-9]*([e][+-]?[0-9]+)?[fFdD]?")String
        if(state.fail)
            return state.fail(start0);
        String arg_2 = state.pickObj();

        state = match(13, state, 3); // arg_3: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_3 = state.pickObj();

        Atom value;
        try{
            value = state.catalog.float_literal(arg_0, arg_1, arg_2, arg_3);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Atom
    static _State rule_41(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(56, state, 1); // arg_1: @Regex("[.][0-9]+([e][+-]?[0-9]+)?[fFdD]?")String
        if(state.fail)
            return state.fail(start0);
        String arg_1 = state.pickObj();

        state = match(13, state, 2); // arg_2: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_2 = state.pickObj();

        Atom value;
        try{
            value = state.catalog.float_literal(arg_0, arg_1, arg_2);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Atom
    static _State rule_42(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(13, state, 0); // arg_0: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_0 = state.pickObj();

        state = match(54, state, 1); // arg_1: Digits
        if(state.fail)
            return state.fail(start0);
        Digits arg_1 = state.pickObj();

        state = match(13, state, 2); // arg_2: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_2 = state.pickObj();

        Atom value;
        try{
            value = state.catalog.int_literal(arg_0, arg_1, arg_2);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Atom
    static _State rule_43(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(46, state, 0); // arg_0: StrConst
        if(state.fail)
            return state.fail(start0);
        StrConst arg_0 = state.pickObj();

        Atom value;
        try{
            value = state.catalog.string_literal(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // regex rule for: @Ch("$")Void
    static _State rule_44(_State state)
    {
        return match_regex(state, 44, pattern_44, 0);
    }
    static final java.util.regex.Pattern pattern_44 = java.util.regex.Pattern.compile("\\$", 0);

    // regex rule for: @Ch("[")Void
    static _State rule_45(_State state)
    {
        return match_regex(state, 45, pattern_45, 0);
    }
    static final java.util.regex.Pattern pattern_45 = java.util.regex.Pattern.compile("\\[", 0);

    // concat rule for: StrConst
    static _State rule_46(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(57, state, 0); // arg_0: @Ch("\"")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_0 = state.pickObj();

        state = match(58, state, 1); // arg_1: int[]
        if(state.fail)
            return state.fail(start0);
        int[] arg_1 = state.pickObj();

        state = match(57, state, 2); // arg_2: @Ch("\"")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_2 = state.pickObj();

        state = match(13, state, 3); // arg_3: OptWs
        if(state.fail)
            return state.fail(start0);
        OptWs arg_3 = state.pickObj();

        StrConst value;
        try{
            value = state.catalog.string(arg_0, arg_1, arg_2, arg_3);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // regex rule for: @Ch("]")Void
    static _State rule_47(_State state)
    {
        return match_regex(state, 47, pattern_47, 0);
    }
    static final java.util.regex.Pattern pattern_47 = java.util.regex.Pattern.compile("\\]", 0);

    // repeat rule for: @Ch(except="\\\" \t\n\r$()+-*/%",range={32,1114111})int[]
    static _State rule_48(_State state) throws _FatalEx
    {
        state = match_repeat(state, 48, 59, 0, Integer.MAX_VALUE);
        if(state.fail)
            return state;
        java.util.ArrayList<Integer> list = state.pickObj();
        int[] array = new int[list.size()];
        for(int i=0; i<list.size(); i++)
            array[i] = list.get(i);
        return state.ok(array);
    }

    // regex rule for: @Regex("MISSING")String
    static _State rule_49(_State state)
    {
        return match_regex_str(state, 49, pattern_49, 0);
    }
    static final java.util.regex.Pattern pattern_49 = java.util.regex.Pattern.compile("MISSING", 0);

    // regex rule for: @Regex("[a-zA-Z_]\\w*")String
    static _State rule_50(_State state)
    {
        return match_regex_str(state, 50, pattern_50, 0);
    }
    static final java.util.regex.Pattern pattern_50 = java.util.regex.Pattern.compile("[a-zA-Z_]\\w*", 0);

    // regex rule for: @Ch("(")Void
    static _State rule_51(_State state)
    {
        return match_regex(state, 51, pattern_51, 0);
    }
    static final java.util.regex.Pattern pattern_51 = java.util.regex.Pattern.compile("\\(", 0);

    // alt rule for: SepBy<Expr,@Ch(",")String>
    static _State rule_52(_State state) throws _FatalEx
    {
        state = match(60, state, 0); // SepBy1<Expr,@Ch(",")String>
        if(!state.fail)
            return state;

        state = match(61, state, 1); // Empty<Expr,@Ch(",")String>
        if(!state.fail)
            return state;

        return state;
    }


    // regex rule for: @Ch(")")Void
    static _State rule_53(_State state)
    {
        return match_regex(state, 53, pattern_53, 0);
    }
    static final java.util.regex.Pattern pattern_53 = java.util.regex.Pattern.compile("\\)", 0);

    // concat rule for: Digits
    static _State rule_54(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(62, state, 0); // arg_0: @Regex("[0-9]+")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        Digits value;
        try{
            value = state.catalog.digits(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // regex rule for: @Regex("[.][0-9]*([e][+-]?[0-9]+)?[fFdD]?")String
    static _State rule_55(_State state)
    {
        return match_regex_str(state, 55, pattern_55, 0);
    }
    static final java.util.regex.Pattern pattern_55 = java.util.regex.Pattern.compile("[.][0-9]*([e][+-]?[0-9]+)?[fFdD]?", 0);

    // regex rule for: @Regex("[.][0-9]+([e][+-]?[0-9]+)?[fFdD]?")String
    static _State rule_56(_State state)
    {
        return match_regex_str(state, 56, pattern_56, 0);
    }
    static final java.util.regex.Pattern pattern_56 = java.util.regex.Pattern.compile("[.][0-9]+([e][+-]?[0-9]+)?[fFdD]?", 0);

    // regex rule for: @Ch("\"")Void
    static _State rule_57(_State state)
    {
        return match_regex(state, 57, pattern_57, 0);
    }
    static final java.util.regex.Pattern pattern_57 = java.util.regex.Pattern.compile("\"", 0);

    // repeat rule for: int[]
    static _State rule_58(_State state) throws _FatalEx
    {
        state = match_repeat(state, 58, 63, 0, Integer.MAX_VALUE);
        if(state.fail)
            return state;
        java.util.ArrayList<Integer> list = state.pickObj();
        int[] array = new int[list.size()];
        for(int i=0; i<list.size(); i++)
            array[i] = list.get(i);
        return state.ok(array);
    }

    // regex rule for: @Ch(except="\\\" \t\n\r$()+-*/%",range={32,1114111})int
    static _State rule_59(_State state) throws _FatalEx
    {
        return match_regex_int(state, 59, pattern_59, 0);
    }
    static final java.util.regex.Pattern pattern_59 = java.util.regex.Pattern.compile("[\\ -\\x{10FFFF}&&[^\\\\\"\\ \\t\\n\\r\\$\\(\\)\\+\\-\\*/%]]", 0);

    // concat rule for: SepBy1<Expr,@Ch(",")String>
    static _State rule_60(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(0, state, 0); // arg_0: Expr
        if(state.fail)
            return state.fail(start0);
        Expr arg_0 = state.pickObj();

        state = match(64, state, 1); // arg_1: List<Seq2<@Ch(",")String,Expr>>
        if(state.fail)
            return state.fail(start0);
        List<Seq2<String, Expr>> arg_1 = state.pickObj();

        SepBy1<Expr, String> value;
        try{
            value = SepBy1.ctor(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Empty<Expr,@Ch(",")String>
    static _State rule_61(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        Empty<Expr, String> value;
        try{
            value = Empty.ctor();
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // regex rule for: @Regex("[0-9]+")String
    static _State rule_62(_State state)
    {
        return match_regex_str(state, 62, pattern_62, 0);
    }
    static final java.util.regex.Pattern pattern_62 = java.util.regex.Pattern.compile("[0-9]+", 0);

    // alt rule for: int
    static _State rule_63(_State state) throws _FatalEx
    {
        state = match(65, state, 0); // int
        if(!state.fail)
            return state;

        state = match(66, state, 1); // int
        if(!state.fail)
            return state;

        state = match(67, state, 2); // int
        if(!state.fail)
            return state;

        return state;
    }


    // repeat rule for: List<Seq2<@Ch(",")String,Expr>>
    static _State rule_64(_State state) throws _FatalEx
    {
        state = match_repeat(state, 64, 68, 0, Integer.MAX_VALUE);
        if(state.fail)
            return state;
        java.util.ArrayList<Seq2<String, Expr>> list = state.pickObj();
        list.trimToSize();
        return state.ok(list);
    }

    // concat rule for: int
    static _State rule_65(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(69, state, 0); // arg_0: @Ch(except="\\\"",range={32,1114111})int
        if(state.fail)
            return state.fail(start0);
        int arg_0 = state.pickObj();

        int value;
        try{
            value = state.catalog.char1(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: int
    static _State rule_66(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(70, state, 0); // arg_0: @Ch("\\")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_0 = state.pickObj();

        state = match(71, state, 1); // arg_1: @Ch("\\\"/bfnrt")char
        if(state.fail)
            return state.fail(start0);
        char arg_1 = state.pickObj();

        int value;
        try{
            value = state.catalog.escC(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: int
    static _State rule_67(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(70, state, 0); // arg_0: @Ch("\\")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_0 = state.pickObj();

        state = match(72, state, 1); // arg_1: @Ch("u")Void
        if(state.fail)
            return state.fail(start0);
        Void arg_1 = state.pickObj();

        state = match(73, state, 2); // arg_2: byte
        if(state.fail)
            return state.fail(start0);
        byte arg_2 = state.pickObj();

        state = match(73, state, 3); // arg_3: byte
        if(state.fail)
            return state.fail(start0);
        byte arg_3 = state.pickObj();

        state = match(73, state, 4); // arg_4: byte
        if(state.fail)
            return state.fail(start0);
        byte arg_4 = state.pickObj();

        state = match(73, state, 5); // arg_5: byte
        if(state.fail)
            return state.fail(start0);
        byte arg_5 = state.pickObj();

        int value;
        try{
            value = state.catalog.escU(arg_0, arg_1, arg_2, arg_3, arg_4, arg_5);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // concat rule for: Seq2<@Ch(",")String,Expr>
    static _State rule_68(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(74, state, 0); // arg_0: @Ch(",")String
        if(state.fail)
            return state.fail(start0);
        String arg_0 = state.pickObj();

        state = match(0, state, 1); // arg_1: Expr
        if(state.fail)
            return state.fail(start0);
        Expr arg_1 = state.pickObj();

        Seq2<String, Expr> value;
        try{
            value = new Seq2<String, Expr>(arg_0, arg_1);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // regex rule for: @Ch(except="\\\"",range={32,1114111})int
    static _State rule_69(_State state) throws _FatalEx
    {
        return match_regex_int(state, 69, pattern_69, 0);
    }
    static final java.util.regex.Pattern pattern_69 = java.util.regex.Pattern.compile("[\\ -\\x{10FFFF}&&[^\\\\\"]]", 0);

    // regex rule for: @Ch("\\")Void
    static _State rule_70(_State state)
    {
        return match_regex(state, 70, pattern_70, 0);
    }
    static final java.util.regex.Pattern pattern_70 = java.util.regex.Pattern.compile("\\\\", 0);

    // regex rule for: @Ch("\\\"/bfnrt")char
    static _State rule_71(_State state) throws _FatalEx
    {
        return match_regex_char(state, 71, pattern_71, 0);
    }
    static final java.util.regex.Pattern pattern_71 = java.util.regex.Pattern.compile("[\\\\\"/bfnrt]", 0);

    // regex rule for: @Ch("u")Void
    static _State rule_72(_State state)
    {
        return match_regex(state, 72, pattern_72, 0);
    }
    static final java.util.regex.Pattern pattern_72 = java.util.regex.Pattern.compile("u", 0);

    // concat rule for: byte
    static _State rule_73(_State state) throws _FatalEx
    {
        final int start0 = state.start;

        state = match(75, state, 0); // arg_0: @Regex("[0-9A-Fa-f]")char
        if(state.fail)
            return state.fail(start0);
        char arg_0 = state.pickObj();

        byte value;
        try{
            value = state.catalog.hex(arg_0);
        }catch(Exception ex){
            throw new _FatalEx(start0, ex);
        }
        return state.ok(value);
    }

    // regex rule for: @Ch(",")String
    static _State rule_74(_State state)
    {
        return match_regex_str(state, 74, pattern_74, 0);
    }
    static final java.util.regex.Pattern pattern_74 = java.util.regex.Pattern.compile(",", 0);

    // regex rule for: @Regex("[0-9A-Fa-f]")char
    static _State rule_75(_State state) throws _FatalEx
    {
        return match_regex_char(state, 75, pattern_75, 0);
    }
    static final java.util.regex.Pattern pattern_75 = java.util.regex.Pattern.compile("[0-9A-Fa-f]", 0);



    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
    //
    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

    static _State match_repeat(_State state, int ruleId, int subRuleId, int min, int max) throws _FatalEx
    {
        final int start0 = state.start;
        java.util.ArrayList<Object> list = new java.util.ArrayList<>(Math.max(min, Math.min(10, max)));
        for(int i=0; i<max; i++)
        {
            final int start1 = state.start;
            state = match(subRuleId, state, i);
            if(i<min && state.fail)
                return state.fail(start0);
            if(i>=min && state.fail) // enough elements
                break;
            if(i>=min && start1==state.start) // no progress, enough elements
                break;
            list.add(state.pickObj());
        }
        return state.ok(list);
    }

    static _State match_regex(_State state, int ruleId, java.util.regex.Pattern pattern, int group)
    {
        var matcher = pattern.matcher(state.chars);
        matcher.region(state.start, state.end);
        boolean matched = matcher.lookingAt();
        if(!matched)
            return state.fail(state.start, failReason_regex, null, ruleId, state.start);

        state.gStart = matcher.start(group);
        state.gEnd = matcher.end(group);
        if(state.gStart==-1)
            return state.fail(state.start, failReason_regex_group, null, ruleId, state.start);

        state.start = matcher.end(0); // consume group 0
        return state.ok(null);
    }
    static _State match_regex_char(_State state, int ruleId, java.util.regex.Pattern pattern, int group) throws _FatalEx
    {
        state = match_regex_int(state, ruleId, pattern, group);
        if(state.fail)
            return state;
        Integer x = state.pickObj();
        if(x>0xFFFF)
        {
            // programming mistake in the regex, or an unexpected input
            String msg = "expected to match exactly 1 char; matched=%s, start=%s, end=%s, regex=%s"
                .formatted(Integer.toHexString(x), state.gStart, state.gEnd, pattern.pattern());
            throw new _FatalEx(state.gStart, new Exception(msg));
        }
        return state.ok(Character.valueOf((char)x.intValue()));
    }
    static _State match_regex_int(_State state, int ruleId, java.util.regex.Pattern pattern, int group) throws _FatalEx
    {
        state = match_regex(state, ruleId, pattern, group);
        if(state.fail)
            return state;
        int count = Character.codePointCount(state.chars, state.gStart, state.gEnd);
        if(count==1)
        {
            int code = Character.codePointAt(state.chars, state.gStart);
            if(Character.charCount(code)==state.gEnd-state.gStart) // could it fail?
                return state.ok(code);
        }
        // programming mistake in the regex, or an unexpected input
        String msg = "expected to match exactly 1 code point; start=%s, end=%s, regex=%s"
            .formatted(state.gStart, state.gEnd, pattern.pattern());
        throw new _FatalEx(state.gStart, new Exception(msg));
    }
    static _State match_regex_str(_State state, int ruleId, java.util.regex.Pattern pattern, int group)
    {
        state = match_regex(state, ruleId, pattern, group);
        if(state.fail)
            return state;
        String str = state.chars.subSequence(state.gStart, state.gEnd).toString();
        return state.ok(str);
    }
    static class _DatatypeList
    {
        // [0] Expr
        static org.knime.core.expressions.parser.ExpressionGrammar.Expr t_0;
        // [1] Disjunction
        static org.knime.core.expressions.parser.ExpressionGrammar.Disjunction t_1;
        // [2] SepBy1<Conjunction,@Str("or")String>
        static org.rekex.helper.datatype.SepBy1<org.knime.core.expressions.parser.ExpressionGrammar.Conjunction,java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"or"})String> t_2;
        // [3] Conjunction
        static org.knime.core.expressions.parser.ExpressionGrammar.Conjunction t_3;
        // [4] List<Seq2<@Str("or")String,Conjunction>>
        static java.util.List<org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"or"})String,org.knime.core.expressions.parser.ExpressionGrammar.Conjunction>> t_4;
        // [5] SepBy1<Inversion,@Str("and")String>
        static org.rekex.helper.datatype.SepBy1<org.knime.core.expressions.parser.ExpressionGrammar.Inversion,java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"and"})String> t_5;
        // [6] Seq2<@Str("or")String,Conjunction>
        static org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"or"})String,org.knime.core.expressions.parser.ExpressionGrammar.Conjunction> t_6;
        // [7] Inversion
        static org.knime.core.expressions.parser.ExpressionGrammar.Inversion t_7;
        // [8] List<Seq2<@Str("and")String,Inversion>>
        static java.util.List<org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"and"})String,org.knime.core.expressions.parser.ExpressionGrammar.Inversion>> t_8;
        // [9] @Str("or")String
        static java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"or"})String t_9;
        // [10] Inversion
        static org.knime.core.expressions.parser.ExpressionGrammar.Inversion t_10;
        // [11] Inversion
        static org.knime.core.expressions.parser.ExpressionGrammar.Inversion t_11;
        // [12] Seq2<@Str("and")String,Inversion>
        static org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"and"})String,org.knime.core.expressions.parser.ExpressionGrammar.Inversion> t_12;
        // [13] OptWs
        static org.knime.core.expressions.parser.ExpressionGrammar.OptWs t_13;
        // [14] @Str("not")String
        static java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"not"})String t_14;
        // [15] Comparison
        static org.knime.core.expressions.parser.ExpressionGrammar.Comparison t_15;
        // [16] @Str("and")String
        static java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"and"})String t_16;
        // [17] @Word("")String
        static java.lang.@org.knime.core.expressions.parser.ExpressionGrammar.Word(value={""})String t_17;
        // [18] Comparison
        static org.knime.core.expressions.parser.ExpressionGrammar.Comparison t_18;
        // [19] Comparison
        static org.knime.core.expressions.parser.ExpressionGrammar.Comparison t_19;
        // [20] Sum
        static org.knime.core.expressions.parser.ExpressionGrammar.Sum t_20;
        // [21] @Str({"==","=","!=","<=","<",">=",">"})String
        static java.lang.@org.rekex.helper.anno.Str(ignoreCase=false, value={"==", "=", "!=", "<=", "<", ">=", ">"})String t_21;
        // [22] SepBy1<Term,@Ch("+-")String>
        static org.rekex.helper.datatype.SepBy1<org.knime.core.expressions.parser.ExpressionGrammar.Term,java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="+-")String> t_22;
        // [23] Term
        static org.knime.core.expressions.parser.ExpressionGrammar.Term t_23;
        // [24] List<Seq2<@Ch("+-")String,Term>>
        static java.util.List<org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="+-")String,org.knime.core.expressions.parser.ExpressionGrammar.Term>> t_24;
        // [25] SepBy1<Factor,@Ch("*/%")String>
        static org.rekex.helper.datatype.SepBy1<org.knime.core.expressions.parser.ExpressionGrammar.Factor,java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="*/%")String> t_25;
        // [26] Seq2<@Ch("+-")String,Term>
        static org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="+-")String,org.knime.core.expressions.parser.ExpressionGrammar.Term> t_26;
        // [27] Factor
        static org.knime.core.expressions.parser.ExpressionGrammar.Factor t_27;
        // [28] List<Seq2<@Ch("*/%")String,Factor>>
        static java.util.List<org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="*/%")String,org.knime.core.expressions.parser.ExpressionGrammar.Factor>> t_28;
        // [29] @Ch("+-")String
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="+-")String t_29;
        // [30] Factor
        static org.knime.core.expressions.parser.ExpressionGrammar.Factor t_30;
        // [31] Factor
        static org.knime.core.expressions.parser.ExpressionGrammar.Factor t_31;
        // [32] Seq2<@Ch("*/%")String,Factor>
        static org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="*/%")String,org.knime.core.expressions.parser.ExpressionGrammar.Factor> t_32;
        // [33] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_33;
        // [34] @Ch("*/%")String
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="*/%")String t_34;
        // [35] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_35;
        // [36] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_36;
        // [37] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_37;
        // [38] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_38;
        // [39] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_39;
        // [40] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_40;
        // [41] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_41;
        // [42] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_42;
        // [43] Atom
        static org.knime.core.expressions.parser.ExpressionGrammar.Atom t_43;
        // [44] @Ch("$")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="$")Void t_44;
        // [45] @Ch("[")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="[")Void t_45;
        // [46] StrConst
        static org.knime.core.expressions.parser.ExpressionGrammar.StrConst t_46;
        // [47] @Ch("]")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="]")Void t_47;
        // [48] @Ch(except="\\\" \t\n\r$()+-*/%",range={32,1114111})int[]
        static @org.rekex.helper.anno.Ch(except="\\\" \t\n\r$()+-*/%", ignoreCase=false, range={32, 1114111}, value="")int[] t_48;
        // [49] @Regex("MISSING")String
        static java.lang.@org.rekex.spec.Regex(flags=0, group=0, value="MISSING")String t_49;
        // [50] @Regex("[a-zA-Z_]\\w*")String
        static java.lang.@org.rekex.spec.Regex(flags=0, group=0, value="[a-zA-Z_]\\w*")String t_50;
        // [51] @Ch("(")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="(")Void t_51;
        // [52] SepBy<Expr,@Ch(",")String>
        static org.rekex.helper.datatype.SepBy<org.knime.core.expressions.parser.ExpressionGrammar.Expr,java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value=",")String> t_52;
        // [53] @Ch(")")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value=")")Void t_53;
        // [54] Digits
        static org.knime.core.expressions.parser.ExpressionGrammar.Digits t_54;
        // [55] @Regex("[.][0-9]*([e][+-]?[0-9]+)?[fFdD]?")String
        static java.lang.@org.rekex.spec.Regex(flags=0, group=0, value="[.][0-9]*([e][+-]?[0-9]+)?[fFdD]?")String t_55;
        // [56] @Regex("[.][0-9]+([e][+-]?[0-9]+)?[fFdD]?")String
        static java.lang.@org.rekex.spec.Regex(flags=0, group=0, value="[.][0-9]+([e][+-]?[0-9]+)?[fFdD]?")String t_56;
        // [57] @Ch("\"")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="\"")Void t_57;
        // [58] int[]
        static int[] t_58;
        // [59] @Ch(except="\\\" \t\n\r$()+-*/%",range={32,1114111})int
        static @org.rekex.helper.anno.Ch(except="\\\" \t\n\r$()+-*/%", ignoreCase=false, range={32, 1114111}, value="")int t_59;
        // [60] SepBy1<Expr,@Ch(",")String>
        static org.rekex.helper.datatype.SepBy1<org.knime.core.expressions.parser.ExpressionGrammar.Expr,java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value=",")String> t_60;
        // [61] Empty<Expr,@Ch(",")String>
        static org.rekex.helper.datatype.SepBy.Empty<org.knime.core.expressions.parser.ExpressionGrammar.Expr,java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value=",")String> t_61;
        // [62] @Regex("[0-9]+")String
        static java.lang.@org.rekex.spec.Regex(flags=0, group=0, value="[0-9]+")String t_62;
        // [63] int
        static int t_63;
        // [64] List<Seq2<@Ch(",")String,Expr>>
        static java.util.List<org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value=",")String,org.knime.core.expressions.parser.ExpressionGrammar.Expr>> t_64;
        // [65] int
        static int t_65;
        // [66] int
        static int t_66;
        // [67] int
        static int t_67;
        // [68] Seq2<@Ch(",")String,Expr>
        static org.rekex.helper.datatype.seq.Seq2<java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value=",")String,org.knime.core.expressions.parser.ExpressionGrammar.Expr> t_68;
        // [69] @Ch(except="\\\"",range={32,1114111})int
        static @org.rekex.helper.anno.Ch(except="\\\"", ignoreCase=false, range={32, 1114111}, value="")int t_69;
        // [70] @Ch("\\")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="\\")Void t_70;
        // [71] @Ch("\\\"/bfnrt")char
        static @org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="\\\"/bfnrt")char t_71;
        // [72] @Ch("u")Void
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value="u")Void t_72;
        // [73] byte
        static byte t_73;
        // [74] @Ch(",")String
        static java.lang.@org.rekex.helper.anno.Ch(except="", ignoreCase=false, range={}, value=",")String t_74;
        // [75] @Regex("[0-9A-Fa-f]")char
        static @org.rekex.spec.Regex(flags=0, group=0, value="[0-9A-Fa-f]")char t_75;

        static final java.util.ArrayList<org.rekex.annotype.AnnoType> list = new java.util.ArrayList<>();
        static
        {
            for(int id=0; id<76; id++)
            {
                java.lang.reflect.Field field;
                try{ field = _DatatypeList.class.getDeclaredField("t_"+id); }
                catch(Exception ex){ ex.printStackTrace(); throw new Error(ex); }
                var type = org.rekex.annotype.TypeMath.convertFromJlr(field.getAnnotatedType());
                list.add(type);
            }
        }
    }

}

